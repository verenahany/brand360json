import React, { useEffect, useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { NormalizedResult } from '@/components/results/types';
import TableEnhancer from '@/components/tables/TableEnhancer';
import SqlQueryDisplay from './SqlQueryDisplay';
import { Globe, ExternalLink, Copy, Download } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';

interface ResultsModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  allResults: {
    sql: NormalizedResult[];
    embedding: NormalizedResult[];
    web: NormalizedResult[];
  };
  activeTab: 'sql' | 'embedding' | 'web' | 'all';
}

const PRIORITY_COLS = [
  'result_source', 'table', 'title', 'name', 'device_name',
  'id', 'primary_id', 'internal_id', 'product_id',
  'result_score', 'availability', 'amount',
  // synthetic embedding columns added below:
  'embedding_len', 'embedding_preview'
];

const ResultsModal: React.FC<ResultsModalProps> = ({
  isOpen,
  onClose,
  title,
  allResults,
  activeTab
}) => {
  const [selectedTab, setSelectedTab] = useState<string>(activeTab);
  const { toast } = useToast();

  useEffect(() => {
    if (isOpen) setSelectedTab(activeTab);
  }, [activeTab, isOpen]);

  const getSqlQuery = () => {
    for (const r of allResults.sql || []) {
      const rec = (r as any).record || r;
      if (rec?.query) return rec.query;
      if (rec?.sql) return rec.sql;
    }
    return null;
  };

  const getCurrentTabData = (): NormalizedResult[] => {
    switch (selectedTab) {
      case 'all':
        return ([...(allResults.sql || []), ...(allResults.embedding || [])] as any) || [];
      case 'sql':
        return allResults.sql || [];
      case 'embedding':
        return allResults.embedding || [];
      case 'web':
        return allResults.web || [];
      default:
        return [];
    }
  };

  // Make a shallow copy and attach synthetic embedding summary if present.
  const attachEmbeddingSummary = (row: any) => {
    const copy: any = { ...row };
    const emb = row?.embedding ?? row?.vector ?? row?.embedding_vector ?? null;
    if (Array.isArray(emb)) {
      copy.embedding_len = emb.length;
      copy.embedding_preview = emb.slice(0, 5).join(', ');
    }
    return copy;
  };

  // Extract rows and preserve/derive a reliable source label.
  const getRowsWithSource = (results: NormalizedResult[]) => {
    const out: { row: any; source: 'sql' | 'embedding' | 'web' | string }[] = [];

    results.forEach((item: any) => {
      const baseSource = (item?.result_source || item?.source || item?.type || '').toString().toLowerCase();

      // normalized shape
      if (item?.record && typeof item.record === 'object') {
        out.push({ row: attachEmbeddingSummary(item.record), source: baseSource as any });
        return;
      }

      // nested results[]
      if (Array.isArray(item?.results)) {
        item.results.forEach((r: any) => {
          const s = (r?.result_source || baseSource || 'sql').toString().toLowerCase();
          out.push({ row: attachEmbeddingSummary(r), source: s as any });
        });
        return;
      }

      // flattened row
      if (item && typeof item === 'object') {
        out.push({ row: attachEmbeddingSummary(item), source: baseSource as any });
      }
    });

    // Final safety filter by selected tab (prevents SQL showing embedding rows and vice-versa)
    if (selectedTab === 'sql')   return out.filter(x => x.source === 'sql');
    if (selectedTab === 'embedding') return out.filter(x => x.source === 'embedding');
    if (selectedTab === 'web')   return out.filter(x => x.source === 'web');
    return out; // 'all'
  };

  const getOrderedColumns = (rowsWithSource: { row: any }[]) => {
    const all = new Set<string>();
    rowsWithSource.forEach(({ row }) => Object.keys(row || {}).forEach(k => all.add(k)));

    // Keep priority cols first (only those that actually exist), then the rest alphabetically
    const presentPriority = PRIORITY_COLS.filter(c => all.has(c));
    const rest = Array.from(all).filter(c => !presentPriority.includes(c)).sort((a,b)=>a.localeCompare(b));
    return [...presentPriority, ...rest];
  };

  const exportCSV = () => {
    const rowsWithSource = getRowsWithSource(getCurrentTabData());
    if (rowsWithSource.length === 0) {
      toast({ title: 'No data to export', description: 'The current tab has no data to export.', variant: 'destructive' });
      return;
    }
    const cols = getOrderedColumns(rowsWithSource);
    const header = cols.join(',');
    const body = rowsWithSource.map(({ row }) =>
      cols.map(col => {
        const v = row[col];
        if (v === null || v === undefined) return '';
        const s = typeof v === 'object' ? JSON.stringify(v) : String(v);
        return s.includes(',') || s.includes('"') || s.includes('\n') ? `"${s.replace(/"/g, '""')}"` : s;
      }).join(',')
    );
    const csv = [header, ...body].join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${selectedTab}-results-${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    toast({ title: 'CSV exported', description: `${selectedTab} results exported.` });
  };

  const renderWebResults = () => {
    const webResults = allResults.web || [];
    if (webResults.length === 0) {
      return <Card className="p-4"><p>No web results available.</p></Card>;
    }

    return (
      <div className="space-y-4">
        {webResults.map((result: any, i: number) => {
          const record = result.record || result || {};
          const title = record.title || result.title || 'No title';
          const url = record.url || result.url || '';
          const content = record.content || record.snippet || 'No content';
          const score = result.result_score || 0;

          let domain = 'Unknown source';
          try {
            if (url) domain = new URL(url).hostname.replace('www.', '');
          } catch {
            domain = (url?.split?.('/')?.[2] || '').replace('www.', '') || 'Unknown source';
          }

          return (
            <Card key={i} className="p-4">
              <div className="flex items-center justify-between mb-2">
                <div className="flex items-center gap-2 text-sm text-muted-foreground">
                  <Globe className="w-4 h-4" />
                  <span>{domain}</span>
                </div>
                {score > 0 && <Badge variant="secondary">{(score * 100).toFixed(1)}% match</Badge>}
              </div>

              <h4 className="font-semibold mb-2">
                {url ? (
                  <a href={url} target="_blank" rel="noopener noreferrer" className="text-primary hover:underline">
                    {title}
                  </a>
                ) : title}
              </h4>

              {url && (
                <div className="flex items-center gap-2 mb-2 text-sm">
                  <a href={url} target="_blank" rel="noopener noreferrer" className="text-muted-foreground hover:underline truncate">
                    {url}
                  </a>
                  <Button variant="ghost" size="sm" onClick={() => navigator.clipboard.writeText(url)} className="p-1 h-auto">
                    <Copy className="w-3 h-3" />
                  </Button>
                </div>
              )}

              <p className="text-sm text-muted-foreground mb-3">{content}</p>
            </Card>
          );
        })}
      </div>
    );
  };

  const renderTableResults = () => {
    const data = getCurrentTabData();
    const rowsWithSource = getRowsWithSource(data);

    if (rowsWithSource.length === 0) {
      return <Card className="p-4"><p>No {selectedTab} results available.</p></Card>;
    }

    const columns = getOrderedColumns(rowsWithSource);
    const sqlQuery = selectedTab === 'sql' ? getSqlQuery() : null;

    return (
      <div className="space-y-4">
        {sqlQuery && selectedTab === 'sql' && <SqlQueryDisplay query={sqlQuery} />}

        <TableEnhancer>
          <table className="w-full">
            <thead className="bg-muted">
              <tr>
                {selectedTab === 'all' && <th className="p-2 text-left">Source</th>}
                {columns.map((c) => (
                  <th key={c} className="p-2 text-left font-medium" title={c}>{c}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {rowsWithSource.slice(0, 100).map(({ row, source }, idx) => (
                <tr key={idx} className="border-t hover:bg-muted/50">
                  {selectedTab === 'all' && (
                    <td className="p-2">
                      <Badge variant={source === 'embedding' ? 'default' : 'secondary'}>
                        {source === 'embedding' ? 'Embedding' : source.toString().toUpperCase()}
                      </Badge>
                    </td>
                  )}
                  {columns.map((col) => (
                    <td key={col} className="p-2 text-sm">
                      {row[col] === null || row[col] === undefined ? (
                        <span className="text-muted-foreground italic">null</span>
                      ) : typeof row[col] === 'object' ? (
                        <code className="text-xs bg-muted px-1 rounded">{JSON.stringify(row[col])}</code>
                      ) : (
                        String(row[col])
                      )}
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </TableEnhancer>

        {rowsWithSource.length > 100 && (
          <Card className="p-3">
            <p className="text-sm text-muted-foreground">
              Showing first 100 rows of {rowsWithSource.length} total results.
            </p>
          </Card>
        )}
      </div>
    );
  };

  const hasSQL = (allResults.sql || []).length > 0;
  const hasEmbedding = (allResults.embedding || []).length > 0;
  const hasWeb = (allResults.web || []).length > 0;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-6xl max-h-[85vh] flex flex-col">
        <DialogHeader className="flex-shrink-0">
          <div className="flex items-center justify-between">
            <DialogTitle>{title}</DialogTitle>
            <Button variant="outline" size="sm" onClick={exportCSV} disabled={getRowsWithSource(getCurrentTabData()).length === 0}>
              <Download className="w-3 h-3 mr-1" />
              Export CSV
            </Button>
          </div>
        </DialogHeader>

        <div className="flex-1 overflow-hidden">
          <Tabs value={selectedTab} onValueChange={setSelectedTab} className="h-full flex flex-col">
            <TabsList className="flex-shrink-0 grid w-full grid-cols-4">
              {(hasSQL || hasEmbedding) && (
                <TabsTrigger value="all">
                  All Results ({(allResults.sql || []).length + (allResults.embedding || []).length})
                </TabsTrigger>
              )}
              {hasSQL && <TabsTrigger value="sql">SQL Results ({(allResults.sql || []).length})</TabsTrigger>}
              {hasEmbedding && <TabsTrigger value="embedding">Embedding Results ({(allResults.embedding || []).length})</TabsTrigger>}
              {hasWeb && <TabsTrigger value="web">Web Results ({(allResults.web || []).length})</TabsTrigger>}
            </TabsList>

            <div className="flex-1 overflow-hidden">
              <TabsContent value="all" className="h-full overflow-y-auto max-h-[65vh] p-1">{renderTableResults()}</TabsContent>
              <TabsContent value="sql" className="h-full overflow-y-auto max-h-[65vh] p-1">{renderTableResults()}</TabsContent>
              <TabsContent value="embedding" className="h-full overflow-y-auto max-h-[65vh] p-1">{renderTableResults()}</TabsContent>
              <TabsContent value="web" className="h-full overflow-y-auto max-h-[65vh] p-1">{renderWebResults()}</TabsContent>
            </div>
          </Tabs>
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default ResultsModal;
