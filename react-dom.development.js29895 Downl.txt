import React, { useState, useEffect, useRef, useCallback } from "react";
import { useAuth } from "@/auth/AuthContext";
import { apiClient } from "@/api/gen/client";
import {
  ChatMessage,
  MilestoneState,
  SSEStreamParser,
  getContextAwareTip,
} from "@/types/chat";
import { StreamEvent } from "@/api/gen/types";
import { ChatSession } from "@/api/gen/types";
import { NormalizedResult } from "@/components/results/types";
import ChatThread from "./ChatThread";
import MessageComposer from "./MessageComposer";
import EnhancedResultsPanel from "@/components/results/EnhancedResultsPanel";
import TableEnhancer from "@/components/tables/TableEnhancer";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { useToast } from "@/hooks/use-toast";
import {
  Sidebar,
  SidebarContent,
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarProvider,
  SidebarTrigger,
  useSidebar,
} from "@/components/ui/sidebar";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Plus,
  MessageCircle,
  Star,
  Archive,
  Trash2,
  Settings,
  LogOut,
  MoreVertical,
  Edit2,
  Search,
  AlertTriangle,
} from "lucide-react";
import { cn } from "@/lib/utils";
import brandLogo from "@/assets/brand360.svg";

// Normalize results to consistent format for both live and historical messages

const normalizeResults = (
  results: any[],
  type: "sql" | "web" | "embedding"
): NormalizedResult[] => {
  if (!Array.isArray(results)) return [];

  return results.flatMap((item: any, index: number) => {
    if (!item) return [];

    if (type === "web") {
      // ---- PATCHED: Handle multiple legacy shapes ----

      // 1. New: Array of results

      if (Array.isArray(item.results)) {
        return item.results.map((result: any, idx: number) => ({
          id: `web-${index}-${idx}`,

          result_source: "web",

          result_score: result.result_score || 0,

          title: result.title || "Untitled",

          url: result.url || "",

          record: {
            snippet: result.content || result.snippet || "",

            content: result.content || result.snippet || "",

            source: result.url
              ? result.url.startsWith("http")
                ? new URL(result.url).hostname
                : result.url
              : "unknown",

            ...result,
          },

          timestamp: result.timestamp || new Date().toISOString(),
        }));
      }

      // 2. PATCH: Single object
      else if (item.results && typeof item.results === "object") {
        return [
          {
            id: `web-${index}-0`,

            result_source: "web",

            result_score: item.results.result_score || 0,

            title: item.results.title || "Untitled",

            url: item.results.url || "",

            record: {
              snippet: item.results.content || item.results.snippet || "",

              content: item.results.content || item.results.snippet || "",

              source: item.results.url
                ? item.results.url.startsWith("http")
                  ? new URL(item.results.url).hostname
                  : item.results.url
                : "unknown",

              ...item.results,
            },

            timestamp: item.results.timestamp || new Date().toISOString(),
          },
        ];
      }

      // 3. Flat: direct web result object
      else if (item.url || item.title) {
        return [
          {
            id: `web-${index}`,

            result_source: "web",

            result_score: item.result_score || 0,

            title: item.title || "Untitled",

            url: item.url || "",

            record: {
              snippet: item.content || item.snippet || "",

              content: item.content || item.snippet || "",

              source: item.url
                ? item.url.startsWith("http")
                  ? new URL(item.url).hostname
                  : item.url
                : "unknown",

              ...item,
            },

            timestamp: item.timestamp || new Date().toISOString(),
          },
        ];
      }

      return [];
    } else {
      // ---- SQL / Embedding logic ----

      if (Array.isArray(item.results)) {
        return item.results.map((record: any, idx: number) => ({
          id: `${type}-${index}-${idx}`,

          result_source: record.result_source || type,

          result_score: record.result_score || 0,

          table: item.table || record.table || "Database Results",

          query: item.query || record.query || "",

          title:
            record.name ||
            record.device_name ||
            record.plan_name ||
            record.title ||
            item.table ||
            "Record",

          record,

          timestamp: record.timestamp || new Date().toISOString(),
        }));
      } else if (
        item.table ||
        item.query ||
        item.name ||
        item.device_name ||
        item.plan_name ||
        Object.keys(item).length > 2
      ) {
        return [
          {
            id: `${type}-${index}`,

            result_source: item.result_source || type,

            result_score: item.result_score || 0,

            table: item.table || "Database Results",

            query: item.query || "",

            title:
              item.name ||
              item.device_name ||
              item.plan_name ||
              item.title ||
              item.table ||
              "Record",

            record: item,

            timestamp: item.timestamp || new Date().toISOString(),
          },
        ];
      }

      return [];
    }
  });
};

const Chat: React.FC = () => {
  // Chat state
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [webSearchEnabled, setWebSearchEnabled] = useState(true);
  const [currentMilestone, setCurrentMilestone] = useState<
    MilestoneState | undefined
  >();
  const [sessionId, setSessionId] = useState<string | null>(null);

  // Session management
  const [sessions, setSessions] = useState<ChatSession[]>([]);
  const [showSessionsPanel, setShowSessionsPanel] = useState(true);
  const [isRenamingSession, setIsRenamingSession] = useState<{
    active: boolean;
    id: string | null;
    title: string;
  }>({
    active: false,
    id: null,
    title: "",
  });
  const [favoriteSessionIds, setFavoriteSessionIds] = useState<string[]>([]);
  const [archivedSessionIds, setArchivedSessionIds] = useState<string[]>([]);
  const [activeFolder, setActiveFolder] = useState<
    "all" | "favorites" | "archived"
  >("all");

  const [searchQuery, setSearchQuery] = useState("");

  // Results panel
  const [showResultsPanel, setShowResultsPanel] = useState(false);
  const [resultsPanelData, setResultsPanelData] = useState<any>(null);
  const [resultsPanelType, setResultsPanelType] = useState<string>("");

  // Session warning
  const [sessionWarning, setSessionWarning] = useState({
    show: false,
    countdown: 0,
  });

  // Handle viewing full results
  const handleViewFullResults = (type: "web" | "sql" | "embedding") => {
    setResultsPanelType(type);
    setShowResultsPanel(true);
  };

  // Refs and utilities
  const streamParserRef = useRef(new SSEStreamParser());
  const currentInteractionIdRef = useRef<string | null>(null);
  const { currentUser, logout } = useAuth();
  const { toast } = useToast();

  // Load sessions on mount
  useEffect(() => {
    loadSessions();
    loadFavoritesAndArchived();
  }, []);

  // Load favorites and archived from localStorage
  const loadFavoritesAndArchived = () => {
    try {
      const storedFavorites = localStorage.getItem("favoriteSessionIds");
      if (storedFavorites) {
        setFavoriteSessionIds(JSON.parse(storedFavorites));
      }

      const storedArchived = localStorage.getItem("archivedSessionIds");
      if (storedArchived) {
        setArchivedSessionIds(JSON.parse(storedArchived));
      }
    } catch (error) {
      console.error("Failed to load favorites/archived:", error);
    }
  };

  // Load sessions from API
  const loadSessions = async () => {
    try {
      console.log("Loading sessions...");
      const sessionsData = await apiClient.getSessions();
      console.log("Sessions loaded:", sessionsData);
      setSessions(sessionsData);
    } catch (error) {
      console.error("Failed to load sessions:", error);
      toast({
        title: "Failed to load sessions",
        description: "Could not load your conversation history",
        variant: "destructive",
      });
    }
  };

  // Create new session
  const createNewSession = async (showToast: boolean = true) => {
    if (!currentUser) return;

    try {
      const newSession = await apiClient.createSession({
        user_id: currentUser.id,
        title: "New Conversation",
      });

      setSessionId(newSession.session_id);
      setMessages([]);
      await loadSessions();

      if (showToast) {
        toast({
          title: "New conversation started",
          description: "You can start chatting now",
        });
      }

      return newSession.session_id;
    } catch (error) {
      console.error("Failed to create session:", error);
      if (showToast) {
        toast({
          title: "Failed to create session",
          description: "Could not start a new conversation",
          variant: "destructive",
        });
      }
      return null;
    }
  };

  // Load session messages
  const loadSession = async (session: ChatSession) => {
    try {
      console.log("Loading session:", session.session_id);
      console.log(
        "API URL will be:",
        `/api/sessions/${session.session_id}/messages`
      );
      setSessionId(session.session_id);

      const messagesData = await apiClient.getSessionMessages(
        session.session_id
      );
      console.log("Session messages loaded:", messagesData);
      console.log("Messages count:", messagesData.length);
      console.log("Message structure (first):", messagesData[0]); // Log first message structure

      if (messagesData.length === 0) {
        console.warn("No messages found for session:", session.session_id);
        console.log("Session details:", session);

        // Try debug endpoint to see what's in the database
        try {
          const debugData = await apiClient.debugSessionMessages(
            session.session_id
          );
          console.log("Debug data for session:", debugData);
        } catch (debugError) {
          console.error("Debug endpoint failed:", debugError);
        }
      }

      const formattedMessages: ChatMessage[] = messagesData.map(
        (msg, index) => {
          // Clean content by removing ALL result blocks and formatting tokens
          let cleanContent = msg.content || "";

          // Comprehensive cleaning - remove all known markers and tokens
          cleanContent = cleanContent
            // Bot type and control markers
            .replace(/\[BOT_TYPE:[^\]]*\]/g, "")
            .replace(/\[DONE\]/g, "")
            .replace(/\[START\]/g, "")
            .replace(/\[END\]/g, "")
            .replace(/\[MILESTONE:[^\]]*\]/g, "")
            // Result blocks with various ending formats
            .replace(/\[SQL_RESULTS\][\s\S]*?\[\/END_SQL_RESULTS\]/g, "")
            .replace(/\[WEB_RESULTS\][\s\S]*?\[\/END_WEB_RESULTS\]/g, "")
            .replace(
              /\[EMBEDDING_RESULTS\][\s\S]*?\[\/END_EMBEDDING_RESULTS\]/g,
              ""
            )
            .replace(/\[SQL_RESULTS\][\s\S]*?\[END_SQL_RESULTS\]/g, "")
            .replace(/\[WEB_RESULTS\][\s\S]*?\[END_WEB_RESULTS\]/g, "")
            .replace(
              /\[EMBEDDING_RESULTS\][\s\S]*?\[END_EMBEDDING_RESULTS\]/g,
              ""
            )
            // Any remaining square bracket control markers
            .replace(/\[[A-Z_]+:[^\]]*\]/g, "")
            .replace(/\[[A-Z_]+\]/g, "")
            .replace(/^```(?:\w+)?\n([\s\S]*?)\n```$/g, "$1")
            // Clean up extra whitespace and newlines
            .replace(/\n\s*\n\s*\n/g, "\n\n") // Reduce multiple newlines to double

            .trim();

          // --- Normalization Fix ---
          let sender: "user" | "assistant" | "system";
          if (msg.sender === "bot") {
            sender = "assistant";
          } else if (msg.sender === "user") {
            sender = "user";
          } else if (msg.sender === "system") {
            sender = "system";
          } else {
            sender = "assistant"; // fallback, just in case
          }

          // Normalize results exactly like live messages to ensure consistent structure
          const normalizedSqlResults = normalizeResults(
            msg.sql_results || [],
            "sql"
          );
          const normalizedWebResults = normalizeResults(
            msg.web_results || [],
            "web"
          );

          console.log(`Message ${index} normalized results:`, {
            sql: normalizedSqlResults.length,
            web: normalizedWebResults.length,
            originalSql: msg.sql_results?.length || 0,
            originalWeb: msg.web_results?.length || 0,
            sqlSample: normalizedSqlResults[0],
            webSample: normalizedWebResults[0],
            originalSqlSample: msg.sql_results?.[0],
            originalWebSample: msg.web_results?.[0],
          });

          return {
            id: msg.message_id || `msg-${index}`,
            sender, // <--- FIXED!
            content: cleanContent,
            timestamp: new Date(msg.timestamp || Date.now()),
            sqlResults: normalizedSqlResults,
            webResults: normalizedWebResults,
            embeddingResults: [],
            isStreaming: false,
          };
        }
      );

      // Set results panel data if there are any results in the loaded messages
      // Collect all results from all messages to populate the results panel
      const allSqlResults = messagesData.flatMap((msg) =>
        normalizeResults(msg.sql_results || [], "sql")
      );
      const allWebResults = messagesData.flatMap((msg) =>
        normalizeResults(msg.web_results || [], "web")
      );

      const allResults = {
        sql: allSqlResults,
        web: allWebResults,
        embedding: [], // Backend doesn't store embedding results separately yet
      };

      // Auto-open results panel if we have any results (like live messages do)
      if (allResults.sql.length > 0 || allResults.web.length > 0) {
        setResultsPanelData(allResults);
        // Prioritize web results if available, otherwise SQL
        setResultsPanelType(allResults.web.length > 0 ? "web" : "sql");
        setShowResultsPanel(true);
      } else {
        // Close results panel if no results
        setShowResultsPanel(false);
        setResultsPanelData(null);
      }

      setMessages(formattedMessages);

      toast({
        title: "Session loaded",
        description: `Loaded ${formattedMessages.length} messages`,
      });
    } catch (error) {
      console.error("Failed to load session:", error);
      toast({
        title: "Failed to load session",
        description: "Could not load the conversation",
        variant: "destructive",
      });
    }
  };

  // Send message and handle streaming response
  const sendMessage = async (messageText: string, webSearch: boolean) => {
    console.log("=== SEND MESSAGE CALLED ===", messageText);
    if (!messageText.trim() || isProcessing) return;

    let currentSessionId = sessionId;

    // If no session, create one first
    if (!currentSessionId) {
      currentSessionId = await createNewSession(false);
      if (!currentSessionId) return; // Failed to create session
    }

    // Check if this is the first message and update session title
    const isFirstMessage = messages.length === 0;
    if (isFirstMessage && currentSessionId) {
      try {
        // Update session title with first message (truncated)
        const titleFromMessage =
          messageText.length > 50
            ? messageText.substring(0, 50) + "..."
            : messageText;

        await apiClient.updateSession(currentSessionId, titleFromMessage);
        await loadSessions();
      } catch (error) {
        console.error("Failed to update session title:", error);
      }
    }

    setIsProcessing(true);
    setCurrentMilestone({
      stage: "START",
      tip: getContextAwareTip(messageText).content,
    });

    // Add user message
    const userMessage: ChatMessage = {
      id: `user-${Date.now()}`,
      sender: "user",
      content: messageText,
      timestamp: new Date(),
    };

    // Add placeholder assistant message
    const assistantMessageId = `assistant-${Date.now()}`;
    const assistantMessage: ChatMessage = {
      id: assistantMessageId,
      sender: "assistant",
      content: "",
      timestamp: new Date(),
      isStreaming: true,
    };

    setMessages((prev) => [...prev, userMessage, assistantMessage]);
    currentInteractionIdRef.current = assistantMessageId;

    try {
      console.log("Sending chat request:", {
        query: messageText,
        session_id: currentSessionId,
        web_search_enabled: webSearch,
      });
      console.log("Expected API endpoint:", "/api/chat");

      // Update sessionId state with current session
      setSessionId(currentSessionId);

      // Start streaming - only send query per OpenAPI spec
      const stream = await apiClient.chat({
        query: messageText,

        session_id: currentSessionId!, // <— pass it explicitly

        web_search_enabled: webSearch, // <— pass it explicitly
      });

      console.log("Stream received:", stream);

      const reader = stream.getReader();
      const decoder = new TextDecoder();
      let assistantContent = "";
      let currentEvent: StreamEvent | null = null;

      while (true) {
        const { done, value } = await reader.read();

        if (done) {
          // When finished, mark assistant as no longer streaming (but DON'T touch content/results)

          setMessages((prev) =>
            prev.map((m) =>
              m.id === currentInteractionIdRef.current
                ? { ...m, isStreaming: false }
                : m
            )
          );

          break;
        }

        const chunk = decoder.decode(value, { stream: true });

        if (!chunk.trim()) continue;

        // Try to parse events (SSE)

        const events = streamParserRef.current.parse(chunk);

        if (events.length > 0) {
          for (const event of events) {
            switch (event.type) {
              case "milestone":
                setCurrentMilestone({
                  stage: event.stage,

                  tip: event.tip,

                  message: event.message,
                });

                break;

              case "token":
                // Append the new token to the existing content in state

                setMessages((prev) =>
                  prev.map((m) =>
                    m.id === currentInteractionIdRef.current
                      ? {
                          ...m,
                          content: (m.content || "") + event.content,
                          isStreaming: true,
                        }
                      : m
                  )
                );

                break;

              case "results": {
                // Normalize results and merge into assistant message

                const normalizedSql = normalizeResults(
                  event.payload.sql || [],
                  "sql"
                );

                const normalizedWeb = normalizeResults(
                  event.payload.web || [],
                  "web"
                );

                const normalizedEmbedding = normalizeResults(
                  event.payload.embedding || [],
                  "embedding"
                );

                setMessages((prev) =>
                  prev.map((m) =>
                    m.id === currentInteractionIdRef.current
                      ? {
                          ...m,

                          sqlResults: normalizedSql,

                          webResults: normalizedWeb,

                          embeddingResults: normalizedEmbedding,

                          isStreaming: true,
                        }
                      : m
                  )
                );

                // Show results panel (auto-selecting tab)

                setResultsPanelData({
                  sql: normalizedSql,

                  web: normalizedWeb,

                  embedding: normalizedEmbedding,
                });

                setResultsPanelType(
                  normalizedWeb.length > 0
                    ? "web"
                    : normalizedSql.length > 0
                    ? "sql"
                    : normalizedEmbedding.length > 0
                    ? "embedding"
                    : ""
                );

                setShowResultsPanel(true);

                break;
              }

              case "final":
                setMessages((prev) =>
                  prev.map((m) =>
                    m.id === currentInteractionIdRef.current
                      ? {
                          ...m,

                          content: event.full_content_markdown ?? m.content,

                          isStreaming: false,

                          // DO NOT touch results! They’re already in state.
                        }
                      : m
                  )
                );

                break;

              case "meta":
                if (event.session_title && currentSessionId) {
                  setSessions((prev) =>
                    prev.map((session) =>
                      session.session_id === currentSessionId
                        ? { ...session, title: event.session_title! }
                        : session
                    )
                  );
                }

                break;

              case "error":
                toast({
                  title: "Stream error",

                  description: event.message,

                  variant: "destructive",
                });

                break;
            }
          }
        } else {
          // Fallback: treat as raw text token (if not SSE-formatted)

          setMessages((prev) =>
            prev.map((m) =>
              m.id === currentInteractionIdRef.current
                ? {
                    ...m,
                    content: (m.content || "") + chunk,
                    isStreaming: true,
                  }
                : m
            )
          );
        }
      }

      // Finalize the assistant message
      setMessages((prev) =>
        prev.map((msg) =>
          msg.id === currentInteractionIdRef.current
            ? { ...msg, isStreaming: false }
            : msg
        )
      );

      console.log(
        "Chat interaction completed - messages should be persisted by backend"
      );
    } catch (error) {
      console.error("Chat error:", error);

      // Update assistant message with error
      setMessages((prev) =>
        prev.map((msg) =>
          msg.id === currentInteractionIdRef.current
            ? {
                ...msg,
                content:
                  "Sorry, I encountered an error processing your request. Please try again.",
                isStreaming: false,
              }
            : msg
        )
      );

      toast({
        title: "Message failed",
        description: "There was an error sending your message",
        variant: "destructive",
      });
    } finally {
      setIsProcessing(false);
      setCurrentMilestone(undefined);
      currentInteractionIdRef.current = null;
      streamParserRef.current.reset();
    }
  };

  // Handle streaming events
  const handleStreamEvent = async (
    event: StreamEvent,
    messageId: string,
    currentContent: string
  ) => {
    switch (event.type) {
      case "milestone":
        setCurrentMilestone({
          stage: event.stage,
          tip: event.tip,
          message: event.message,
        });
        break;

      case "token":
        setMessages((prev) =>
          prev.map((msg) =>
            msg.id === messageId
              ? { ...msg, content: currentContent + event.content }
              : msg
          )
        );
        break;

      case "results":
        if (event.payload) {
          setResultsPanelData(event.payload);
          setResultsPanelType("sql"); // Default to SQL tab
          setShowResultsPanel(true);
        }
        break;

      case "final":
        setMessages((prev) =>
          prev.map((msg) =>
            msg.id === messageId
              ? {
                  ...msg,
                  content: event.full_content_markdown,
                  isStreaming: false,
                }
              : msg
          )
        );
        break;

      case "meta":
        if (event.session_title && sessionId) {
          // Update session title
          setSessions((prev) =>
            prev.map((session) =>
              session.session_id === sessionId
                ? { ...session, title: event.session_title! }
                : session
            )
          );
        }
        break;

      case "error":
        console.error("Stream error:", event.message);
        toast({
          title: "Stream error",
          description: event.message,
          variant: "destructive",
        });
        break;
    }
  };

  // Session management functions
  const startRenameSession = (session: ChatSession) => {
    setIsRenamingSession({
      active: true,
      id: session.session_id,
      title: session.title,
    });
  };

  const confirmRenameSession = async () => {
    if (!isRenamingSession.id || !isRenamingSession.title.trim()) return;

    try {
      await apiClient.updateSession(
        isRenamingSession.id,
        isRenamingSession.title.trim()
      );
      await loadSessions();
      setIsRenamingSession({ active: false, id: null, title: "" });

      toast({
        title: "Session renamed",
        description: "Conversation title has been updated",
      });
    } catch (error) {
      console.error("Failed to rename session:", error);
      toast({
        title: "Rename failed",
        description: "Could not update the conversation title",
        variant: "destructive",
      });
    }
  };

  const deleteSession = async (sessionToDelete: ChatSession) => {
    try {
      await apiClient.deleteSession(sessionToDelete.session_id);

      // If it's the current session, clear it
      if (sessionId === sessionToDelete.session_id) {
        setSessionId(null);
        setMessages([]);
      }

      await loadSessions();

      toast({
        title: "Session deleted",
        description: "Conversation has been removed",
      });
    } catch (error) {
      console.error("Failed to delete session:", error);
      toast({
        title: "Delete failed",
        description: "Could not delete the conversation",
        variant: "destructive",
      });
    }
  };

  const handleLogout = async () => {
    try {
      await logout();
      toast({
        title: "Logged out",
        description: "You have been successfully logged out",
      });
    } catch (error) {
      console.error("Logout error:", error);
      toast({
        title: "Logout failed",
        description: "There was an error logging out",
        variant: "destructive",
      });
    }
  };

  // Toggle favorite status for a session
  const toggleFavoriteSession = (sessionId: string) => {
    setFavoriteSessionIds((prevIds) => {
      const newIds = prevIds.includes(sessionId)
        ? prevIds.filter((id) => id !== sessionId)
        : [...prevIds, sessionId];

      try {
        localStorage.setItem("favoriteSessionIds", JSON.stringify(newIds));
      } catch (error) {
        console.error("Failed to store favorites:", error);
      }

      return newIds;
    });
  };

  // Toggle archive status for a session
  const toggleArchiveSession = (sessionId: string) => {
    setArchivedSessionIds((prevIds) => {
      const newIds = prevIds.includes(sessionId)
        ? prevIds.filter((id) => id !== sessionId)
        : [...prevIds, sessionId];

      try {
        localStorage.setItem("archivedSessionIds", JSON.stringify(newIds));
      } catch (error) {
        console.error("Failed to store archived:", error);
      }

      return newIds;
    });
  };

  // Filter sessions based on active folder
  const filteredSessions = sessions.filter((session) => {
    const matchesSearch = session.title
      .toLowerCase()
      .includes(searchQuery.toLowerCase());
    const isArchived = archivedSessionIds.includes(session.session_id);
    const isFavorite = favoriteSessionIds.includes(session.session_id);

    if (activeFolder === "all") {
      return matchesSearch && !isArchived;
    } else if (activeFolder === "favorites") {
      return matchesSearch && isFavorite && !isArchived;
    } else if (activeFolder === "archived") {
      return matchesSearch && isArchived;
    }

    return false;
  });

  return (
    <SidebarProvider>
      <div className="min-h-screen flex w-full bg-background">
        {/* Sidebar */}
        <Sidebar className="border-r">
          <SidebarContent>
            {/* Logo Header */}
            <div className="p-4 border-b">
              <div className="flex items-center gap-3">
                <div className="w-8 h-8 flex items-center justify-center">
                  <img src={brandLogo} alt="Brand360" className="h-6 w-auto" />
                </div>
                <div className="flex-1 min-w-0">
                  <p className="font-medium text-sm">Brand360.ai</p>
                  <p className="text-xs text-muted-foreground">AI Assistant</p>
                </div>
              </div>
            </div>

            {/* New Conversation */}
            <div className="p-4 border-b">
              <Button
                onClick={() => createNewSession(true)}
                className="w-full justify-start"
                variant="outline"
              >
                <Plus className="w-4 h-4 mr-2" />
                New Conversation
              </Button>
            </div>

            {/* Search */}
            <div className="p-4 border-b">
              <Input
                placeholder="Search conversations..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full"
              />
            </div>

            {/* Folders */}
            <SidebarGroup className="px-2">
              <SidebarGroupContent>
                <SidebarMenu>
                  <SidebarMenuItem>
                    <SidebarMenuButton
                      isActive={activeFolder === "all"}
                      onClick={() => setActiveFolder("all")}
                    >
                      <MessageCircle className="w-4 h-4" />
                      <span>All Conversations</span>
                    </SidebarMenuButton>
                  </SidebarMenuItem>
                  <SidebarMenuItem>
                    <SidebarMenuButton
                      isActive={activeFolder === "favorites"}
                      onClick={() => setActiveFolder("favorites")}
                    >
                      <Star className="w-4 h-4" />
                      <span>Favorites</span>
                      {favoriteSessionIds.length > 0 && (
                        <Badge variant="secondary" className="ml-auto">
                          {favoriteSessionIds.length}
                        </Badge>
                      )}
                    </SidebarMenuButton>
                  </SidebarMenuItem>
                  <SidebarMenuItem>
                    <SidebarMenuButton
                      isActive={activeFolder === "archived"}
                      onClick={() => setActiveFolder("archived")}
                    >
                      <Archive className="w-4 h-4" />
                      <span>Archived</span>
                      {archivedSessionIds.length > 0 && (
                        <Badge variant="secondary" className="ml-auto">
                          {archivedSessionIds.length}
                        </Badge>
                      )}
                    </SidebarMenuButton>
                  </SidebarMenuItem>
                </SidebarMenu>
              </SidebarGroupContent>
            </SidebarGroup>

            {/* Sessions List */}
            <SidebarGroup className="flex-1 overflow-hidden">
              <SidebarGroupLabel>
                {activeFolder === "all" && "Recent Conversations"}
                {activeFolder === "favorites" && "Favorite Conversations"}
                {activeFolder === "archived" && "Archived Conversations"}
              </SidebarGroupLabel>
              <SidebarGroupContent className="overflow-y-auto">
                <SidebarMenu>
                  {filteredSessions.map((session) => (
                    <SidebarMenuItem key={session.session_id}>
                      <div className="flex items-center w-full">
                        <SidebarMenuButton
                          asChild
                          isActive={sessionId === session.session_id}
                          className="flex-1"
                        >
                          <button
                            onClick={() => loadSession(session)}
                            className="flex items-center gap-2 w-full"
                          >
                            <MessageCircle className="w-4 h-4" />
                            <span className="truncate">
                              {isRenamingSession.active &&
                              isRenamingSession.id === session.session_id ? (
                                <Input
                                  value={isRenamingSession.title}
                                  onChange={(e) =>
                                    setIsRenamingSession((prev) => ({
                                      ...prev,
                                      title: e.target.value,
                                    }))
                                  }
                                  onBlur={confirmRenameSession}
                                  onKeyDown={(e) => {
                                    if (e.key === "Enter")
                                      confirmRenameSession();
                                    if (e.key === "Escape")
                                      setIsRenamingSession({
                                        active: false,
                                        id: null,
                                        title: "",
                                      });
                                  }}
                                  className="h-6 text-xs"
                                  autoFocus
                                />
                              ) : (
                                session.title
                              )}
                            </span>
                          </button>
                        </SidebarMenuButton>

                        {/* Session Actions */}
                        <DropdownMenu>
                          <DropdownMenuTrigger asChild>
                            <Button
                              variant="ghost"
                              size="icon"
                              className="w-6 h-6"
                            >
                              <MoreVertical className="w-3 h-3" />
                            </Button>
                          </DropdownMenuTrigger>
                          <DropdownMenuContent
                            align="end"
                            className="w-48 z-50 bg-popover border shadow-md"
                          >
                            <DropdownMenuItem
                              onClick={() =>
                                toggleFavoriteSession(session.session_id)
                              }
                            >
                              <Star
                                className={cn(
                                  "w-3 h-3 mr-2",
                                  favoriteSessionIds.includes(
                                    session.session_id
                                  ) && "fill-current"
                                )}
                              />
                              {favoriteSessionIds.includes(session.session_id)
                                ? "Unfavorite"
                                : "Add to favorites"}
                            </DropdownMenuItem>
                            <DropdownMenuItem
                              onClick={() => startRenameSession(session)}
                            >
                              <Edit2 className="w-3 h-3 mr-2" />
                              Rename
                            </DropdownMenuItem>
                            <DropdownMenuItem
                              onClick={() =>
                                toggleArchiveSession(session.session_id)
                              }
                            >
                              <Archive className="w-3 h-3 mr-2" />
                              {archivedSessionIds.includes(session.session_id)
                                ? "Unarchive"
                                : "Archive"}
                            </DropdownMenuItem>
                            <DropdownMenuItem
                              onClick={() => deleteSession(session)}
                              className="text-destructive focus:text-destructive"
                            >
                              <Trash2 className="w-3 h-3 mr-2" />
                              Delete
                            </DropdownMenuItem>
                          </DropdownMenuContent>
                        </DropdownMenu>
                      </div>
                    </SidebarMenuItem>
                  ))}
                </SidebarMenu>
              </SidebarGroupContent>
            </SidebarGroup>

            {/* User Info at Bottom */}
            <div className="p-4 border-t mt-auto">
              <div className="flex items-center gap-3">
                <div className="w-8 h-8 bg-muted rounded-full flex items-center justify-center">
                  <span className="text-xs font-medium">
                    {currentUser?.name?.charAt(0).toUpperCase() || "U"}
                  </span>
                </div>
                <div className="flex-1 min-w-0">
                  <p className="font-medium text-sm truncate">
                    {currentUser?.name}
                  </p>
                  <p className="text-xs text-muted-foreground truncate">
                    {currentUser?.email}
                  </p>
                </div>
                <Button variant="ghost" size="icon" onClick={handleLogout}>
                  <LogOut className="w-4 h-4" />
                </Button>
              </div>
            </div>
          </SidebarContent>
        </Sidebar>

        {/* Main Content */}
        <div className="flex-1 flex flex-col">
          {/* Header */}
          <header className="h-16 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 flex items-center px-4">
            <SidebarTrigger />
            <div className="flex-1 flex items-center justify-between ml-4">
              <div>
                <h1 className="text-lg font-semibold">Brand360.ai Chat</h1>
                {sessionId && (
                  <p className="text-sm text-muted-foreground">
                    Current session:{" "}
                    {sessions.find((s) => s.session_id === sessionId)?.title ||
                      "Unknown"}
                  </p>
                )}
              </div>

              <div className="flex items-center gap-2">
                {/* Session Warning */}
                {sessionWarning.show && (
                  <div className="flex items-center gap-2 px-3 py-1 bg-warning/10 text-warning rounded-md">
                    <AlertTriangle className="w-4 h-4" />
                    <span className="text-sm">
                      Session expires in {sessionWarning.countdown}s
                    </span>
                  </div>
                )}

                {/* Results Panel Toggle */}
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setShowResultsPanel(!showResultsPanel)}
                  className={cn(showResultsPanel && "bg-accent")}
                >
                  <Search className="w-4 h-4 mr-2" />
                  Results
                  {resultsPanelData && (
                    <Badge variant="secondary" className="ml-2">
                      {Array.isArray(resultsPanelData)
                        ? resultsPanelData.length
                        : "•"}
                    </Badge>
                  )}
                </Button>
              </div>
            </div>
          </header>

          {/* Chat Content */}
          <div className="flex-1 flex">
            <div className="flex-1 flex flex-col">
              <ChatThread
                messages={messages}
                currentMilestone={currentMilestone}
                onViewFullResults={handleViewFullResults}
              />
              <MessageComposer
                onSendMessage={sendMessage}
                onInputFocus={() => {
                  // Start new session when clicking input if no session exists
                  if (!sessionId && messages.length === 0) {
                    createNewSession(false);
                  }
                }}
                isLoading={isProcessing}
                webSearchEnabled={webSearchEnabled}
                onWebSearchToggle={setWebSearchEnabled}
              />
            </div>
          </div>
        </div>

        {/* Results Panel */}
        <EnhancedResultsPanel
          isVisible={showResultsPanel}
          onClose={() => setShowResultsPanel(false)}
          resultData={resultsPanelData}
          resultType={resultsPanelType}
        />
      </div>
    </SidebarProvider>
  );
};

export default Chat;
